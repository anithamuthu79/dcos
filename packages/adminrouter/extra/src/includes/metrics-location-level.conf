# Output fine-grained location directive level metrics using the VTS module.
#
# Caution:
# A request which matches a location that has a VTS module filter defined will be
# counted on the Nginx location directive level filter but it will not be counted
# on a filter defined on the server directive level that it matches as well.
#
# The following filter expects a $upstream_tag to be set before importing in order to
# identify the upstream that the metrics belong to. This constitutes a mechanism to
# annotate the Admin Router config, allowing one to collect metrics of dynamically
# resolved upstreams on the fly. It is also the name that will show up in Grafana when
# referring to a particular upstream. Grouping metrics based on upstream would normally
# only be possible with Nginx Plus because only then they can be defined in a upstream
# directive and continue to be dynamically resolved.
# https://tenzer.dk/nginx-with-dynamic-upstreams/

# Create a counter for every backend that requests go to when passing this line in a location directive.
# Tag the counter with the manually set upstream.
vhost_traffic_status_filter_by_set_key backend=$upstream_addr ,upstream=${upstream_tag},;

# Create a counter for every status of requests which pass this line in a location directive.
# Tag the counter with the manually set upstream and the backend that the request was passed on to.
vhost_traffic_status_filter_by_set_key status=$status ,upstream=${upstream_tag},backend=${upstream_addr},;

# Create a counter for every URI that requests go to when passing this line in a location directive.
# Tag the counter with the manually set upstream, the backend that the request was passed on to and the resulting status code.
vhost_traffic_status_filter_by_set_key uri=$uri ,upstream=${upstream_tag},backend=${upstream_addr},status=${status},uri;

# Create a counter for every client that requests where sent from that pass this line in a location directive.
# Tag the counter with the manually set upstream, the backend that the request was passed on to and the resulting status code.
vhost_traffic_status_filter_by_set_key client=$http_user_agent ,upstream=${upstream_tag},backend=${upstream_addr},status=${status},client;

# Another thing to keep in mind is that if this file is imported before a LUA auth check
# block and authorization for the request is denied, the reported $upstream_addr value
# would be empty. We chose to import it afterwards so that an unauthorized request is
# counted at the server directive level filter. This choice implies losing the information
# that the denied request was going to go to e.g. the IAM, which might be an unacceptable
# trade-off in favor cleanliness and easy of building Grafana graphs. The nice property
# of this solution is that only requests which really went to the upstream are counted
# in the filters introduced through upstream metric annotation.
